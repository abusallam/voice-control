#!/usr/bin/env python3

import tkinter as tk
from tkinter import ttk

class App(tk.Tk):
    def update_status(self):
        try:
            with open("/tmp/voice-control-status", "r") as f:
                status = f.read()
                self.status_bar.config(text=status)
        except FileNotFoundError:
            self.status_bar.config(text="Idle")
        self.after(1000, self.update_status)

    def record_hotkey(self):
        self.hotkey_window = tk.Toplevel(self)
        self.hotkey_window.title("Record Hotkey")
        self.hotkey_window.geometry("200x100")

        label = ttk.Label(self.hotkey_window, text="Press a key combination.")
        label.pack()

        self.hotkey_window.bind("<KeyPress>", self.on_key_press)

    def on_key_press(self, event):
        hotkey = f"<{'ctrl' if event.state & 4 else ''}{'alt' if event.state & 8 else ''}{'shift' if event.state & 1 else ''}>+{event.keysym}"
        self.hotkey_var.set(hotkey)
        self.hotkey_display.config(text=hotkey)
        self.hotkey_window.destroy()

    def __init__(self):
        super().__init__()

        self.title("Nerd Dictation Settings")
        self.geometry("500x400")

        self.create_widgets()

    def create_widgets(self):
        # Model selection
        model_label = ttk.Label(self, text="Speech Recognition Model:")
        model_label.pack()

        self.model_var = tk.StringVar()
        model_combobox = ttk.Combobox(self, textvariable=self.model_var)
        model_combobox['values'] = ('Whisper', 'CMU Sphinx')
        model_combobox.pack()

        # Hotkey selection
        hotkey_label = ttk.Label(self, text="Hotkey:")
        hotkey_label.pack()

        self.hotkey_var = tk.StringVar()
        hotkey_frame = ttk.Frame(self)
        hotkey_frame.pack()

        self.hotkey_label = ttk.Label(hotkey_frame, text="Current Hotkey:")
        self.hotkey_label.pack(side=tk.LEFT)

        self.hotkey_display = ttk.Label(hotkey_frame, text=self.hotkey_var.get())
        self.hotkey_display.pack(side=tk.LEFT)

        record_hotkey_button = ttk.Button(hotkey_frame, text="Record New Hotkey", command=self.record_hotkey)
        record_hotkey_button.pack(side=tk.LEFT)

        # Auto punctuation
        self.auto_punctuation_var = tk.BooleanVar()
        auto_punctuation_checkbutton = ttk.Checkbutton(
            self,
            text="Enable automatic punctuation",
            variable=self.auto_punctuation_var
        )
        auto_punctuation_checkbutton.pack()

        # Save button
        save_button = ttk.Button(self, text="Save", command=self.save_settings)
        save_button.pack()

        self.status_bar = ttk.Label(self, text="Idle", relief=tk.SUNKEN, anchor=tk.W)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)

    def save_settings(self):
        import configparser
        import os

        config = configparser.ConfigParser()
        config['settings'] = {
            'model': self.model_var.get(),
            'hotkey': self.hotkey_var.get(),
            'auto_punctuation': self.auto_punctuation_var.get()
        }

        config_dir = os.path.expanduser("~/.config/voice-control")
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)

        with open(os.path.join(config_dir, 'settings.ini'), 'w') as configfile:
            config.write(configfile)

    def load_settings(self):
        import configparser
        import os

        config = configparser.ConfigParser()
        config_path = os.path.expanduser("~/.config/voice-control/settings.ini")
        if os.path.exists(config_path):
            config.read(config_path)
            self.model_var.set(config.get('settings', 'model', fallback='Whisper'))
            self.hotkey_var.set(config.get('settings', 'hotkey', fallback='<ctrl>+<alt>+d'))
            self.auto_punctuation_var.set(config.getboolean('settings', 'auto_punctuation', fallback=False))

    def __init__(self):
        super().__init__()

        self.title("Nerd Dictation Settings")
        self.geometry("400x300")

        self.create_widgets()
        self.load_settings()
        self.update_status()

if __name__ == "__main__":
    app = App()
    app.mainloop()
